;;; z/nZ

(defun enumerate (n)
  (do ((k n (1- k))
       (loc nil (cons k loc)))
      ((zerop k) loc)))

(defun divides-p (x y)
  "Predicate procedure retrns true when x|y (x divides y)."
  (if (equal (rem y x) 0)
      t
      nil))

(defun divisors-list (n)
  "Procedure returns list of divisors of n."
  (do ((k n (1- k))
       (loc nil (if (divides-p k n) (cons k loc) loc)))
      ((zerop k) loc)))

(defun proper-divisors-list (n)
  "Procedure returns list of proper divisors of n."
  (butlast (cdr (divisors-list n))))

(defun coprime-p (x y)
  "Procedure tests relative primality of integers x and y."
  (if (= (gcd x y) 1)
      t
      nil))

(defun coprimes-list (n)
  "Procedure returns residues modulo n."
  (do ((k (1- n) (1- k))
       (res nil (if (coprime-p k n) (cons k res) res)))
      ((zerop k) res)))

(defun group-order (n)
  "Procedure returns order of multiplicative group of integers modulo n."
  (length (coprimes-list n)))

(defun element-inverse (k n)
  "Procedure returns inverse of k in multiplicative group of integers mod n."
  (do ((in (coprimes-list n) (cdr in)))
      ((= (rem (* k (car in)) n) 1) (car in))))

(defun inverses-p (x y k)
  "Predicate procedure true if x and y are inverses congruent modulo k."
  (if (= (rem (* x y) k) 1)
      t
      nil))

(defun element-inverses (group)
  "Procedure constricts list of inverses of group."
  ;;; Using pairlis better!?
  (let ((n (1+ (car (last group)))))
    (do ((s1 (reverse group) (cdr s1))
	 (res
	  nil
	  (do ((s2 group (cdr s2)))
	      ((inverses-p (car s1) (car s2) n)
	       (cons (car s2) res)))))
	((null s1) res))))

;;; test should yield list of ones of length of coprimes group
;; (mapcar #'(lambda (x y) (rem (* x y) 50)) (coprimes-list 50) (element-inverses (coprimes-list 50)))

(defun element-order (k n)
  "Procedure returns order of k in  multiplicative group of inetegers mod n."
  (do ((j 1 (1+ j)))
      ((= (rem (expt k j) n) 1) j)))

(defun element-orders (group)
  "Procedure constructs list of orders of elements of group."
  ;;; pairlis?!
  (let ((n (1+ (car (last group)))))
    (do ((seq (reverse group) (cdr seq))
	 (res nil (cons (element-order (car seq) n) res)))
	((null seq) res))))

;; (defun generate (element n)
;;   "Procedure constructs cyclic subgroup generated by powers of element."
;;   (labels ((recur (k subgroup)
;; 	     (let ((m (rem (expt element k) n)))
;; 	       (if (= m 1)
;; 		   (reverse (cons m subgroup))
;; 		   (recur (1+ k) (cons m subgroup))))))
;;     (recur 1 nil)))

(defun generate (element n)
  "Procedure constructs cyclic subgroup generated by powers of element congruent
   modulo n."
  (when (coprime-p element n)
    (do ((i 1 (1+ i))
	 (loc nil (cons (rem (expt element i) n) loc)))
	((equal (car loc) 1) (reverse loc)))))

(defun subgroups-list (group n)
  "Procedure constructs list of subgroups of group."
  (do ((g group (cdr g))
       (res nil (cons (generate (car g) n) res)))
      ((null g) res)))

(defun subgroups-table (group n)
  "Procedure returns hash-table of cyclic subgroups of group."
  (let ((hash-table (make-hash-table)))
    (dolist (element group hash-table)
      (setf (gethash element hash-table) (generate element n)))))

(defun extract-orders (hash-table)
  "Procedure extracts subgroups (values) from subgroups hash-table."
  (let ((orders nil))
    (maphash #'(lambda (generator subgroup) (declare (ignore generator))
		 (setf orders (cons (length subgroup) orders)))
	     hash-table)
    orders))

(defun maximum-subgroup-order (hash-table)
  "Procedure finds maximum order of subgroups (values) in hash-table."
  (reduce #'max (extract-orders hash-table)))

(defun cyclic-p (n)
  "Procedure predicate true when group of residues modulo n is cyclic."
  (let ((group (coprimes-list n)))
    (dolist (element group)
      (when (equal (length (generate element n)) (length group))
	(return-from cyclic-p t)))
    nil))

(defun cyclic-groups-list (n)
  "Procedure constructs list of cyclic residue groups mod k up to n."
  (do ((k n (1- k))
       (loc nil (if (cyclic-p k) (cons k loc) loc)))
      ((zerop k) loc)))

(defun cyclic-groups-list-2 (n)
  "Procedure constructs list of cyclic residue groups mod k up to n."
  (remove-if-not #'cyclic-p (enumerate n)))

(defun hash-table-alist (hash-table)
  "Process converts hash-table into association list."
  (let ((alist nil))
    (maphash
     (lambda (key value) (push (cons key value) alist))
     hash-table)
    alist))

;;; Josh Roybal found this one somewhat complicated.
(defun subgroups-alist (ht)
  "Harvest distinct hash-table values and their keys."
  (let ((res nil))
    (maphash
     #'(lambda (k v)
	 (let ((subgroup (sort (copy-seq v) #'<))) ;; don't destroy table
	   (if (not (member subgroup (mapcar #'car res) :test 'equalp))
	       (setf res (acons subgroup (list k) res))
	       (let ((value (assoc subgroup res :test 'equalp)))
		 (rplacd value (cons k (cdr value)))))))
     ht)
    res))

(defun cayley-table (g n)
  "Procedure constructs Cayley Table for residues of n."
  (let ((in (reverse g)))
    (do ((s1 in (cdr s1))
	 (table
	  nil
	  (cons
	   (do ((s2 in (cdr s2))
		(row nil (cons (rem (* (car s1) (car s2)) n) row)))
	       ((null s2) row))
	   table)))
	((null s1) table))))

(defun print-cayley-table (group n)
  "Procedure pretty-prints Cayley Table."
  (let* ((table (cayley-table (sort group #'<) n))
	 (width (length (write-to-string (reduce #'max group))))
	 (fmt (get-format (1+ width))))
    (progn
      (format t "~&Cayley Table")
      (format t "~&")
      (format t fmt "*")
      (dolist (i group)
	(format t fmt i))
      (do ((g group (cdr g))
	   (in table (cdr in)))
	  ((null g))
	(progn
	  (format t "~&")
	  (format t fmt (car g))
	  (dolist (col (car in))
	    (format t fmt col))))      
      )))

(defun print-group-order (g)
  (format t "~&|z/~dZ| = ~d" (1+ (car (last g))) (length g)))

(defun print-subgroup (key value)
  (format t "~&<~d> = ~S" key value))


(defun group-report (n)
  "Procedure displays strucutre of multiplicative group of integers mod n."
  (let* ((group (coprimes-list n))
	 (group-order (length group))
	 (cyclic-table (subgroups-table group n))
	 (cyclic-alist (subgroups-alist cyclic-table)))
    (progn
      (format t "~&z/~dZ = ~S" n group)
      (print-group-order group)
      (format t "~&divisors of |z/~dZ| = ~S" n (divisors-list group-order))
      ;;; print group Cayley Table
      (print-cayley-table group n)
      (format t "~%~%")
      ;;;determine whether group is cyclic
      (if (equal (maximum-subgroup-order cyclic-table) (length group))
	  (format t "~&z/~dZ is cyclic." n)
	  (format t "~&z/~dZ is not cyclic." n))
      ;;; generate subgroups
      (format t "~&cyclic subgroups")
      ;;; first unsorted/non-distinct
      ;; (maphash #'print-subgroup cyclic-table)
      ;;; then sorted/distinct
      (dolist (x cyclic-alist)
	;;; subgroups are (car x)
	;;; generators are (cdr x)
	(progn
	  (format t "~&")
	  (dolist (y (cdr x))
	    (format t "<~d> = " y))
	  (format t "~S~%" (car x))
	  (dolist (y (cdr x))
	    (format t "|<~d>| = " y))
	  (format t "~d" (length (car x)))
	  (format t
		  "~&|z/~dZ| / |~S| = ~d"
		  n (car x) (/ (length group) (length (car x))))
	  ;;(print-cayley-table (car x) n)
	  (format t "~%~%")
	  ))
      (format t "no. of distinct cyclic subgroups = ~d" (length cyclic-alist))
      (format t "~&no. of divisiors of |z/~dZ| = ~d" n
	      (length (divisors-list (length group))))
      'done)))

(defun get-format (n)
  (concatenate 'string "~" (write-to-string n) "d"))

(defun tabulate (n)
  (progn
    (format t "~&~40@a" "order")
    (format t "~&~10@a~10@a~10@a~10@a" "n" "order" "subgroups" "divisors")
    (do* ((i 2 (1+ i))
	  (group (coprimes-list i) (coprimes-list i))
	  (order (group-order i) (group-order i))
	  (no-subgroups
	   (length (subgroups-alist (subgroups-table group i)))
	   (length (subgroups-alist (subgroups-table group i))))
	  (no-divisors
	   (length (divisors-list order))
	   (length (divisors-list order))))
	 ((> i n) 'done)
      (progn
	(format t "~&~10d~10d~10d~10d" i order no-subgroups no-divisors)
	(when (cyclic-p i) (format t "  cyclic"))))))
