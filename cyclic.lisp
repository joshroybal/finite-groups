;;; z/nZ

(defun coprime-p (x y)
  "Procedure tests relative primality of integers x and y."
  (if (= (gcd x y) 1)
      t
      nil))

(defun coprimes-list (n)
  "Procedure returns residues modulo n."
  (do ((k n (1- k))
       (res nil (if (coprime-p k n) (cons k res) res)))
      ((zerop k) res)))

(defun group-order (n)
  "Procedure returns order of multiplicative group of integers modulo n."
  (length (coprimes-list n)))

(defun element-inverse (k n)
  "Procedure returns inverse of k in multiplicative group of integers mod n."
  (do ((in (coprimes-list n) (cdr in)))
      ((= (rem (* k (car in)) n) 1) (car in))))

(defun inverses-p (x y k)
  (if (= (rem (* x y) k) 1)
      t
      nil))

(defun element-inverses (group)
  (let ((n (1+ (car (last group)))))
    (do ((s1 (reverse group) (cdr s1))
	 (res
	  nil
	  (do ((s2 group (cdr s2)))
	      ((inverses-p (car s1) (car s2) n)
	       (cons (car s2) res)))))
	((null s1) res))))

;;; test should yield list of ones of length of coprimes group
;; (mapcar #'(lambda (x y) (rem (* x y) 50)) (coprimes-list 50) (element-inverses (coprimes-list 50)))

(defun element-order (k n)
  "Procedure returns order of k in  multiplicative group of inetegers mod n."
  (do ((j 1 (1+ j)))
      ((= (rem (expt k j) n) 1) j)))

(defun element-orders (group)
  (let ((n (1+ (car (last group)))))
    (do ((seq (reverse group) (cdr seq))
	 (res nil (cons (element-order (car seq) n) res)))
	((null seq) res))))

(defun generate (element n)
  "Procedure constructs cyclic subgroup generated by powers of element."
  (labels ((recur (k subgroup)
	     (let ((m (rem (expt element k) n)))
	       (if (equal m 1)
		   (reverse (cons m subgroup))
		   (recur (1+ k) (cons m subgroup))))))
    (recur 1 nil)))

(defun subgroups-list (group n)
  "Procedure constructs list of subgroups of group."
  (do ((g group (cdr g))
       (res nil (cons (generate (car g) n) res)))
      ((null g) res)))

(defun subgroups-table (group n)
  "Procedure returns hash-table of cyclic subgroups of group."
  (let ((hash-table (make-hash-table)))
    (dolist (element group hash-table)
      (setf (gethash element hash-table) (generate element n)))))

;;; Josh Roybal found this one somewhat complicated.
(defun subgroups-alist (ht)
  "Harvest distinct hash-table values and their keys."
  (let ((res nil))
    (maphash
     #'(lambda (k v)
	 (let ((subgroup (sort (copy-seq v) #'<)))
	   (if (not (member subgroup (mapcar #'car res) :test 'equalp))
	       (setf res (acons subgroup (list k) res))
	       (let ((value (assoc subgroup res :test 'equalp)))
		 (rplacd value (cons k (cdr value)))))))
     ht)
    res))

(defun cayley-table (g n)
  "Procedure constructs Cayley Table for residues of n."
  (let ((in (reverse g)))
    (do ((s1 in (cdr s1))
	 (table
	  nil
	  (cons
	   (do ((s2 in (cdr s2))
		(row nil (cons (rem (* (car s1) (car s2)) n) row)))
	       ((null s2) row))
	   table)))
	((null s1) table))))

(defun print-cayley-table (group n)
  "Procedure pretty-prints Cayley Table."
  (let* ((table (cayley-table (sort group #'<) n))
	 (width (length (write-to-string (reduce #'max group))))
	 (fmt (concatenate 'string "~" (write-to-string (1+ width)) "d"))
	 (afmt (concatenate 'string "~" (write-to-string (1+ width)) "@a")))
    (progn
      (format t "~&Cayley Table")
      (format t "~&")
      (format t afmt "*")
      (dolist (i group)
	(format t fmt i))
      (do ((g group (cdr g))
	   (in table (cdr in)))
	  ((null g))
	(progn
	  (format t "~&")
	  (format t fmt (car g))
	  (dolist (col (car in))
	    (format t fmt col))))      
      )))

(defun print-subgroup (key value)
  (format t "~&<~d> = ~S" key value))

(defun group-report (n)
  "Procedure displays strucutre of multiplicative group of integers mod n."
  (let* ((group (coprimes-list n))
	 (cyclic-table (subgroups-table group n))
	 (cyclic-alist (subgroups-alist cyclic-table))
	 (maximum-subgroup-order
	   (reduce #'max
		   (mapcar
		    #'(lambda (x) (length (car x)))
		    cyclic-alist))))
    (progn
      (format t "~&z/~dZ = ~S" n group)
      (format t "~&|z/~dZ| = ~d" n (length group))
      (if (equal maximum-subgroup-order (length group))
	  (format t "~&z/~dZ is cyclic." n)
	  (format t "~&z/~dZ is not cyclic." n))
      ;; (if (equal
      ;; 	   (reduce #'max
      ;; 		   (loop for value being the hash-values of cyclic-table
      ;; 			 collect (length value)))
      ;; 	   (length group))
      ;; 	  (format t "~&z/~dZ is cyclic." n)
      ;; 	  (format t "~&z/~dZ is not cyclic." n))
      ;;; print group Cayley Table
      (print-cayley-table group n)
      (format t "~%~%")
      ;;; generate subgroups
      (format t "~&cyclic subgroups")
      (maphash #'print-subgroup cyclic-table)
      (format t "~&distinct cyclic subgroups")
      (dolist (x cyclic-alist)
	;;; subgroups are (car x)
	;;; generators are (cdr x)
	(progn
	  (format t "~&")
	  (dolist (y (cdr x))
	    (format t "<~d> = " y))
	  (format t "~S~%" (car x))
	  (dolist (y (cdr x))
	    (format t "|<~d>| = " y))
	  (format t "~d" (length (car x)))
	  (format t "~%~%")))
      'done)))
